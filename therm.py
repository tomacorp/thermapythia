#!/Users/toma/python278i/bin/python
# Tom Anderson
# Thermal simulation prototype
# Sun Jul 13 22:30:26 PDT 2014
#
# TODO:  Read Xyce source code to see their matrix algorithms.
#        Create test harness for sweeps of problem size.
#        Hook up PNG files.
#        Do a DC analysis instead of TRAN, check memory usage.
#        Measure xyce memory usage with 
#          http://stackoverflow.com/questions/13607391/subprocess-memory-usage-in-python

import subprocess, os
import pstats
import cProfile
import matplotlib.pyplot as plt
import numpy as np
from PyTrilinos import Epetra, AztecOO, ML, Anasazi, Amesos

class Layers:
  def __init__(self):

# Field layers for double float values in mesh.field
    self.iso = 0
    self.heat = 1
    self.resis = 2
    self.deg = 3
    self.flux = 4
    self.isodeg = 5
    self.spicedeg = 6
    self.numdoublelayers = 7

# Field layers for integer values in mesh.ifield
    self.isonode = 0
    self.isoflag = 1
    self.spicenodenum = 2
    self.numintlayers = 3


# Convergence monitor
class Monitors:
  def __init__(self):
    self.maxtemp = -273
    self.powerin = 0
    self.powerout = 0
    self.verbose = 0

# Mesh the field
class Mesh:

  """
  Mesh: Square mesher class for thermal analysis.
  
  The mesher takes a number of squares in the x and y direction and creates
  a square mesh from it.
  
  Counts the number of cells and the number of Dirichlet boundary conditions.
  This is required for sizing the Pytrilinos matrix before loading it.
  These Dirichlet count is needed because the boundaries also have an associated thermal
  resistance between the boundary and the square mesh.
  This resistance results in an additional node for every boundary square.
  
  Creates a bidirectional mapping from the integer X,Y 2D space to the 1D node list
  that is used for solving the sparse matrix.
  
  """

  def __init__(self, w, h, lyr, matls):
    self.width = w
    self.height = h
    self.field = np.zeros((self.width, self.height, lyr.numdoublelayers), dtype = 'double')
    self.ifield = np.zeros((self.width, self.height, lyr.numintlayers), dtype = 'int')
    self.xr, self.yr= np.mgrid[0:self.width+1, 0:self.height+1]
    self.nodeGcount = 0
    self.nodeDcount = 0
    self.nodeCount = 0
    self.nodeGBcount = 0
    self.nodeGFcount = 0 
    # Field name dictionary to map self.spicenodenum layer to string values
    # The key is the spicenodename and the value is the spicenodenum.
    self.spiceNodeName = {}
    # Dictionary that maps a node name string to the X and Y coordinates in the mesh.
    self.spiceNodeXName = {}
    self.spiceNodeYName = {}
    # Array where the index is the spicenodenum and the values are the x and y of in the mesh.
    # This allows a sequence of ordered nodes in the spice raw file output to be loaded directly back into
    # a layer in the mesh. Nodes start at 1. The first variable is time.
    self.spiceNodeX = []
    self.spiceNodeY = []
    self.field[:, :, lyr.heat]  = 0.0
    self.field[:, :, lyr.resis] = matls.copperCond
    self.field[:, :, lyr.deg]   = 20
    self.field[:, :, lyr.flux]  = 0.0
    self.field[:, :, lyr.isodeg] = 25.0
    self.ifield[:, :, lyr.isoflag] = 0
    self.ifield[:, :, lyr.isonode] = 0    

  def solveTemperatureNodeCount(self):
    """ 
    solveTemperatureNodeCount(Mesh self)
    Returns the count of cells in the square mesh.
    """
    # The node count is one more than the maximum index.
    # getNodeAtXY starts a 0
    count= self.getNodeAtXY(self.width - 1, self.height - 1) + 1
    return count

  def boundaryDirichletNodeCount(self, lyr):
    """
    boundaryDirichletNodeCount(Mesh self, int lyr)
    Returns the count of the nodes generated by adding Dirichlet boundary conditions.

    """
    count = 0;
    for x in range(0, self.width):
      for y in range(0, self.height):
        if (self.ifield[x, y, lyr.isoflag] == 1):
          count = count + 1
    return count

  def getNodeAtXY(self, x, y):
    """
    getNodeAtXY(Mesh self, int x, int y)
    Given an integer x and y argument, find the corresponding node number
    """
    node= x + (y * self.width)
    return node

  def getXAtNode(self, node):
    """
    def getXAtNode(Mesh self, int node)
    Given a node, find the x coordinate of the mesh element
    """
    if (node > self.width * self.height - 1):
      return ''
    x = node % self.width
    return x
  
  def getYAtNode(self, node):
    """
    def getXAtNode(Mesh self, int node)
    Given a node, find the y coordinate of the mesh element
    """    
    if (node > self.width * self.height - 1):
      return ''
    x = self.getXAtNode(node)
    y = node - x
    y = y / self.width
    return y

  def mapMeshToSolutionMatrix(self, lyr):
    """
    mapMeshToSolutionMatrix(Mesh self, Layers lyr)
    Based on the mesh, find the number of the different types of nodes
    that will be in the matrix A. These numbers need to be known in
    advance of constructing the matrix.
    The input is the width and height of the mesh, and the field with
    the location of the Dirichlet boundary condition nodes.
    One node is for the 1 off-diagonal entries for the voltage sources,
    and the second node is because there is a resistor that connects
    the Dirichlet boundary condition to the mesh. This means that the
    voltage source creates another voltage node.
    """
    self.nodeGcount = self.getNodeAtXY(self.width - 1, self.height - 1)
    self.nodeCount = self.nodeGcount + 1
    self.nodeGFcount = self.nodeCount
    # Find the number of nodes in the submatrices
    for x in range(0, self.width):
      for y in range(0, self.height):
        if (self.ifield[x, y, lyr.isoflag] == 1):
          # print "Mapping mesh isothermal node at (x, y) = (", x, ", ", y, ")"
          # Every boundary condition gets a new node
          self.nodeGcount = self.nodeGcount + 1
          self.nodeGBcount = self.nodeGBcount + 1
          self.nodeCount = self.nodeCount + 1
          # Every boundary condition gets a new voltage source
          self.nodeDcount = self.nodeDcount + 1
          self.ifield[x, y, lyr.isonode] = self.nodeGcount
          self.nodeCount = self.nodeCount + 1
    self.nodeGcount = self.nodeGcount + 1
    print "Number of independent nodes in G matrix= ", self.nodeGcount
    print "Number of independent nodes in GF matrix= ", self.nodeGFcount
    print "Number of independent nodes in GB matrix= ", self.nodeGBcount
    print "Number of independent nodes in D matrix= ", self.nodeDcount
    print "Total number of independent nodes= ", self.nodeCount

class Matls:
  def __init__(self):
    self.fr4Cond    = 0
    self.copperCond = 10
    self.boundCond = 20
    
class interactivePlot:
  def __init__(self, lyr, mesh):
    self.lyr     = lyr
    self.mesh    = mesh  

  def plotsolution(self):
    """
    plotsolution(interactivePlot self)
    Plot the problem grids and also the solution grid.
    """
    self.plotResistance()
    self.plotTemperature()
    self.plotDirichlet()
    self.plotHeatSources()
    self.plotSpicedeg()
    self.plotIsotherm()
    self.show()

  def show(self):
    plt.show()

  def plotIsotherm(self):
    """
    Make a plot that shows which nodes have Dirichlet boundary conditions
    attached to them through a resistor
    """
    z5= self.mesh.ifield[:, :, self.lyr.isoflag]; 
    plt.figure(5)
    plt.subplot(1,1,1)
    plt.axes(aspect=1)
    quad4= plt.pcolormesh(self.mesh.xr, self.mesh.yr, z5)
    plt.colorbar()
    plt.title('Nodes with Dirichlet boundary conditions map')
    plt.draw()

  def plotHeatSources(self):
    """
    Make a plot that shows which nodes have heat sources attached.
    """
    z4= self.mesh.field[:, :, self.lyr.heat];
    plt.figure(4)
    plt.subplot(1,1,1)
    plt.axes(aspect=1)
    quad4= plt.pcolormesh(self.mesh.xr, self.mesh.yr, z4)
    plt.colorbar()
    plt.title('Heat sources map')
    plt.draw()

  def plotDirichlet(self):
    """
    Make a plot that shows the relative temperature of the Dirichlet
    boundary condition nodes.
    """
    z3= self.mesh.field[:, :, self.lyr.isodeg];
    plt.figure(3)
    plt.subplot(1,1,1)
    plt.axes(aspect=1)
    quad3= plt.pcolormesh(self.mesh.xr, self.mesh.yr, z3)
    plt.colorbar()
    plt.title('Dirichlet boundary conditions temperature map')
    plt.draw()

  def plotTemperature(self):
    """
    Make a plot that shows the temperature of the mesh nodes.
    """
    plt.figure(2)
    z2= self.mesh.field[:, :, self.lyr.deg];
    plt.subplot(1,1,1)
    plt.axes(aspect=1)
    quad2= plt.pcolormesh(self.mesh.xr, self.mesh.yr, z2)
    plt.colorbar()
    plt.title('AztecOO heat map')
    plt.draw()

  def plotResistance(self):
    """
    Make a plot that shows the thermal resistance of the materials in the mesh nodes.
    """
    z1= self.mesh.field[:, :, self.lyr.resis];
    plt.figure(1)
    plt.subplot(1,1,1)
    plt.axes(aspect=1)
    quad1= plt.pcolormesh(self.mesh.xr, self.mesh.yr, z1)
    plt.colorbar()
    plt.title('Thermal resistance map')
    plt.draw()
    
  def plotSpicedeg(self):
    """
    Make a plot that shows the temperature of the mesh nodes as simulated by Xyce.
    """
    z1= self.mesh.field[:, :, self.lyr.spicedeg];
    plt.figure(1)
    plt.subplot(1,1,1)
    plt.axes(aspect=1)
    quad1= plt.pcolormesh(self.mesh.xr, self.mesh.yr, z1)
    plt.colorbar()
    plt.title('Spice heat map')
    plt.draw() 
    
  def plotLayerDifference(self, layer1, layer2):
    """
    Make a plot that shows the difference between two values in the mesh.
    """
    z1= self.mesh.field[:, :, layer1];
    z2= self.mesh.field[:, :, layer2];
    z3= z1 - z2
    plt.figure(1)
    plt.subplot(1,1,1)
    plt.axes(aspect=1)
    quad1= plt.pcolormesh(self.mesh.xr, self.mesh.yr, z3)
    plt.colorbar()
    plt.title('Difference heat map')
    plt.draw()    
    
    
class Webpage:

  def __init__(self, solv, lyr, mesh):
    self.html    = ''
    self.solver = solv
    self.lyr = lyr
    self.mesh = mesh
    self.maxWebPageSize = 100
    
  def createWebPage(self):
    matrixSize= self.mesh.solveTemperatureNodeCount()
    if matrixSize > self.maxWebPageSize:
      print "Web page skipped because problem size is " + matrixSize + " which is larger than limit " + self.maxWebPageSize
      return
    print "Creating web page"
    np.set_printoptions(threshold='nan', linewidth=10000)
    f= open('result.html', 'w')
    self.webpage()
    f.write(self.html)
    f.close()  
    
  def webpage(self):
    matrix= ''
    rhsStr= ''
    xhtml= ''
    col= 0
    cols= '* '
  
    temperatureStartNode= 0
    temperatureEndNode= self.mesh.solveTemperatureNodeCount()
    dirichletStartNode= temperatureEndNode
    dirichletEndNode= dirichletStartNode + self.mesh.boundaryDirichletNodeCount(self.lyr)
  
    rowType = ''
    for n in range(0, self.solver.NumGlobalElements):
      nodeType= '?'
      if ((n >= temperatureStartNode) and (n < temperatureEndNode)):
        nodeType= 'matl'
      else:
        if ((n >= dirichletStartNode) and (n < dirichletEndNode)):
          nodeType = 'diri'
      rowType = rowType + "<td>" + nodeType + "</td>"
  
    rowX = ''
    for n in range(0, self.solver.NumGlobalElements):
      x = self.mesh.getXAtNode(n)
      rowX = rowX + "<td>" + str(x) + "</td>"
    rowY = ''
    for n in range(0, self.solver.NumGlobalElements):
      y = self.mesh.getYAtNode(n)
      rowY = rowY + "<td>" + str(y) + "</td>"
  
    # Create matrix table
    for x in range(0, self.solver.NumGlobalElements):
      rhsStr = rhsStr + "<td>" + str("%.3f" % self.solver.bs[x]) + "</td>"
   #   xhtml = xhtml + "<td>" + str("%.3f" % self.solver.x[x]) + "</td>"
      matrix_row = ''
      for y in range(0, self.solver.NumGlobalElements):
        if self.solver.As[x,y] != 0.0:
          elt= str("%.3f" % self.solver.As[x,y])
        else:
          elt= '.'
        matrix_row = matrix_row + "<td>" + elt + "</td>"
      matrix= matrix + "<tr>" + matrix_row + "</tr>"
      cols = cols + "<td>" + str(col) + "</td>"
      col = col + 1
    matrix = "<table>" + matrix + "</table>"
    
    mostCommon= self.solver.nonzeroMostCommonCount()
  
    # Create vector table
    vectors =           "<tr><td><b>col</b></td>" + cols + "</tr>"
    vectors = vectors + "<tr><td><b>X</b></td>" + rowX + "</tr>"
    vectors = vectors + "<tr><td><b>Y</b></td>" + rowY + "</tr>"
    vectors = vectors + "<tr><td><b>Type</b></td>" + rowType + "</tr>"
    vectors = vectors + "<tr><td><b>rhs</b></td>" + rhsStr + "</tr>"
    vectors = vectors + "<tr><td><b>lhs</b></td>" + xhtml + "</tr>"
    vectors = "<table>" + vectors + "</table>"
  
    # Counts
    counts = "<tr><td>BodyNodeCount</td><td>" + str(self.solver.BodyNodeCount) + "</td></tr>"
    counts += "<tr><td>TopEdgeNodeCount</td><td>" + str(self.solver.TopEdgeNodeCount) + "</td></tr>"
    counts += "<tr><td>RightEdgeNodeCount</td><td>" + str(self.solver.RightEdgeNodeCount) + "</td></tr>"
    counts += "<tr><td>BottomEdgeNodeCount</td><td>" + str(self.solver.BottomEdgeNodeCount) + "</td></tr>"
    counts += "<tr><td>LeftEdgeNodeCount</td><td>" + str(self.solver.LeftEdgeNodeCount) + "</td></tr>"
    counts += "<tr><td>TopLeftCornerNodeCount</td><td>" + str(self.solver.TopLeftCornerNodeCount) + "</td></tr>"
    counts += "<tr><td>TopRightCornerNodeCount</td><td>" + str(self.solver.TopRightCornerNodeCount) + "</td></tr>"
    counts += "<tr><td>BottomRightCornerNodeCount</td><td>" + str(self.solver.BottomRightCornerNodeCount) + "</td></tr>"
    counts += "<tr><td>BoundaryNodeCount</td><td>" + str(self.solver.BoundaryNodeCount) + "</td></tr>"
    counts += "<tr><td>Total NodeCount</td><td>" + str(self.solver.totalNodeCount()) + "</td></tr>"
    counts += "<tr><td>Matrix Size</td><td>" + str(self.solver.NumGlobalElements) + "</td></tr>"
  
    counts += "Number of independent nodes in G matrix= " + str(self.mesh.nodeGcount) + "<br/>"
    counts += "Number of independent nodes in GF matrix= " + str(self.mesh.nodeGFcount) + "<br/>"
    counts += "Number of independent nodes in GB matrix= " + str(self.mesh.nodeGBcount) + "<br/>"
    counts += "Number of independent nodes in D matrix= " + str(self.mesh.nodeDcount) + "<br/>"
    counts += "Total number of independent nodes= " + str(self.mesh.nodeCount) + "<br/>"
    counts += "Most Common number of nonzero matrix entries per row= " + str(mostCommon) + "<br/>"
    counts = "<table>" + counts + "</table>"
  
    # Create web page
    head  = "<title>Matrix output</title>"
    body  = "<h1>Ax = b</h1>"
    body += "<h3>A Matrix</h3>"
    body += "<pre>" + matrix + "</pre>"
    body += "<h3>Vectors</h3>"
    body += "<pre>" + vectors + "</pre>"
    body += "<h3>Counts</h3>"
    body += "<pre>" + counts + "</pre>"
    self.html= "<html><head>" + head + "</head><body>" + body + "</body></html>"  

class Solver:
  """
  The Solver class loads a matrix and solves it.
  It also optionally loads a spice netlist and a debugging structure.
  
  A matrix is in sections:
    
        |  G   B  |
    A = |  C   D  |
       G transconductance matrix
       B sources, which in this case are just 1s
       C transpose of B
       D zeroes
    G is in two sections, which are the upper left GF (for field) and GB (for boundary)
    The analysis is of the form  Ax = b
    For rows in b corresponding to G,  
       b is the known value of the current (constant power in thermal circuits) sources
    For rows in b corresponding to D, (constant temperature boundary conditions) 
       b is the known value of temperature at the boundary.
    The number of rows in D is self.nodeDcount
    The number of rows in G is self.nodeGcount
    The number of rows in GF is self.nodeGFcount
    The number of rows in GB is self.nodeGBcount
    The total number of rows in A is self.nodeCount
  
    The solution to the matrix is the vector x
    For rows in x corresponding to G, these are voltages (temperature)
    For rows in x corresponding to D, these are currents (power flow) in the boundary condition.
  
    For energy balance in steady state, the current into the constant-temperature boundary condition 
    must equal the current from the constant-power thermal sources.
  
    The index of the last nodes in the G submatrix for the field plus one is the number
    of nodes in the field GF. Add the boundary nodes GB to G.
  
    Also count the number of boundary sources, which is the size of the D matrix.   
  """

  def __init__(self, lyr, mesh):
    """
    define the communicator (Serial or parallel, depending on your configure
    line), then initialize a distributed matrix of size 4. The matrix is empty,
    `0' means to allocate for 0 elements on each row (better estimates make the
    code faster). `NumMyElements' is the number of rows that are locally hosted 
    by the calling processor; `MyGlobalElements' is the global ID of locally 
    hosted rows.
    """
    self.debug             = False
    self.spice             = False
    self.aztec             = False
    self.amesos            = True
    self.eigen             = False   
    
    mostCommonNonzeroEntriesPerRow = 5
    self.Comm              = Epetra.PyComm()
    self.NumGlobalElements = mesh.nodeCount
    self.Map               = Epetra.Map(self.NumGlobalElements, 0, self.Comm)
    self.A                 = Epetra.CrsMatrix(Epetra.Copy, self.Map, mostCommonNonzeroEntriesPerRow)
    self.NumMyElements     = self.Map.NumMyElements()
    self.MyGlobalElements  = self.Map.MyGlobalElements()
    
    self.b                 = Epetra.Vector(self.Map)
      
    self.isoIdx            = 0

    self.deck              = ''
    self.GDamping          = 0.0   # Various values such as 1e-12, 1e-10, and -1e-10 have worked or not!
    self.s                 = 'U'
    self.BodyNodeCount              = 0
    self.TopEdgeNodeCount           = 0
    self.RightEdgeNodeCount         = 0
    self.BottomEdgeNodeCount        = 0
    self.LeftEdgeNodeCount          = 0
    self.TopLeftCornerNodeCount     = 0
    self.TopRightCornerNodeCount    = 0
    self.BottomRightCornerNodeCount = 0
    self.BottomLeftCornerNodeCount  = 0
    self.BoundaryNodeCount          = 0
    # Make a python shadow data structure that records what is inside the Epetra data structures.
    # This is a non-sparse version used for debugging.
    # This can be used to print out what is going on.
    # Without it, the data structure is hard to access.
    self.bs= []
    self.x= []    
    
  def initDebug(self):
    if self.debug == True:
      self.As = np.zeros((self.NumGlobalElements, self.NumGlobalElements), dtype = 'double')
      self.bs = np.zeros(self.NumGlobalElements)

  def loadMatrix(self, lyr, mesh, matls):
    """
    The field transconductance matrix GF is in nine sections:
      
        top left corner      |     top edge      |     top right corner
        left edge            |     body          |     right edge
        bottom left corner   |     bottom edge   |     bottom right corner
    
    A is the problem matrix
    Modified nodal analysis formulation is from:
    http://www.swarthmore.edu/NatSci/echeeve1/Ref/mna/MNA2.html
    """
    self.isoIdx = mesh.nodeGFcount
    print "Starting iso nodes at ", self.isoIdx
    
    self.loadMatrixBottomLeftCorner(lyr, mesh, matls)
    self.loadMatrixBottomRightCorner(lyr, mesh, matls)
    self.loadMatrixBottomEdge(lyr, mesh, matls)
    self.loadMatrixTopRightCorner(lyr, mesh, matls)
    self.loadMatrixTopLeftCorner(lyr, mesh, matls) 
    self.loadMatrixRightEdge(lyr, mesh, matls)
    self.loadMatrixTopEdge(lyr, mesh, matls)
    self.loadMatrixLeftEdge(lyr, mesh, matls)
    self.loadMatrixBody(lyr, mesh, matls)  
    self.loadMatrixHeatSources(lyr, mesh)

  def loadMatrixHeatSources(self, lyr, mesh):
    """
    b is the RHS, which are current sources for injected heat and voltage sources for 
    dirichlet boundary conditions.
    """
    # Add the injected heat sources.
    for x in range(0, mesh.width):
      for y in range(0, mesh.height):
        nodeThis= mesh.getNodeAtXY(x, y)
        self.b[nodeThis]= mesh.field[x, y, lyr.heat]
        if self.debug == True:
          self.bs[nodeThis]= mesh.field[x, y, lyr.heat]
        if self.spice == True:
          if (mesh.field[x, y, lyr.heat] != 0.0):
            thisSpiceNode=   "N" + str(x) + self.s + str(y)
            thisHeatSource=   "I" + thisSpiceNode
            thisHeat= -mesh.field[x, y, lyr.heat]
            self.deck += thisHeatSource + " " + thisSpiceNode + " 0 DC " + str(thisHeat) + "\n"

  # This is the bottleneck
  # RAM requirement is about 1kb/mesh element.
  def loadMatrixBody(self, lyr, mesh, matls):
    if (mesh.height < 3) or (mesh.width < 3):
      return
    GBoundary= matls.boundCond
    for x in range(1, mesh.width-1):
      for y in range(1, mesh.height-1):
        
        # 2.067s
        nodeThis, nodeRight, nodeUp, nodeLeft, nodeDown = \
          self.getNeighborNodeNumbers(y, x, mesh)
        
        # 0.747s
        nodeResis, nodeRightResis, nodeUpResis, nodeLeftResis, nodeDownResis = \
        self.rnodeCalc(y, x, mesh, lyr)
        
        # 1.022s
        GRight, GUp, GLeft, GDown, GNode = \
        self.gnodeCalc(nodeResis, nodeRightResis, nodeUpResis, nodeLeftResis, nodeDownResis)
        
        self.BodyNodeCount += 1
        if (mesh.ifield[x, y, lyr.isoflag] == 1):
          if self.debug == True:
            print "Setting boundaryNode body", nodeThis, " at ",x,",",y,", to temp", mesh.field[x, y, lyr.isodeg]
          GNode = self.addIsoNode(lyr, mesh, matls, nodeThis, x, y, GNode)
        
        if (self.aztec == True) or (self.amesos == True):
          # 6.074s
          self.loadBodyA(nodeThis, GNode, GRight, nodeRight, GUp, nodeUp, nodeLeft, GLeft, GDown, nodeDown)
          
        if self.debug == True:
          self.As[nodeThis, nodeThis]= GNode
          self.As[nodeThis, nodeRight]= -GRight
          self.As[nodeRight, nodeThis]= -GRight
          self.As[nodeThis, nodeUp]= -GUp
          self.As[nodeUp, nodeThis]= -GUp
          self.As[nodeThis, nodeLeft]= -GLeft
          self.As[nodeLeft, nodeThis]= -GLeft
          self.As[nodeThis, nodeDown]= -GDown
          self.As[nodeDown, nodeThis]= -GDown
        if self.spice == True:
          thisSpiceNode=   "N" + str(x)   + self.s + str(y)
          spiceNodeRight=  "N" + str(x+1) + self.s + str(y)
          spiceNodeDown=   "N" + str(x)   + self.s + str(y+1)
          mesh.spiceNodeXName[thisSpiceNode] = x
          mesh.spiceNodeYName[thisSpiceNode] = y
          RRight= 1.0/GRight
          RDown=  1.0/GDown
          self.deck += "RFR" + thisSpiceNode + " " + thisSpiceNode + " " + spiceNodeRight + " " + str(RRight) + "\n"
          self.deck += "RFD" + thisSpiceNode + " " + thisSpiceNode + " " + spiceNodeDown + " " + str(RDown) + "\n"

  def loadBodyA(self, nodeThis, GNode, GRight, nodeRight, GUp, nodeUp, nodeLeft, GLeft, GDown, nodeDown):
    self.A[nodeThis, nodeThis]= GNode
    self.A[nodeThis, nodeRight]= -GRight
    self.A[nodeRight, nodeThis]= -GRight
    self.A[nodeThis, nodeUp]= -GUp
    self.A[nodeUp, nodeThis]= -GUp
    self.A[nodeThis, nodeLeft]= -GLeft
    self.A[nodeLeft, nodeThis]= -GLeft
    self.A[nodeThis, nodeDown]= -GDown
    self.A[nodeDown, nodeThis]= -GDown

  def getNeighborNodeNumbers(self, y, x, mesh):
    nodeThis  = mesh.getNodeAtXY(x,   y)
    nodeRight = mesh.getNodeAtXY(x+1, y)
    nodeUp    = mesh.getNodeAtXY(x,   y-1)
    nodeLeft  = mesh.getNodeAtXY(x-1, y)
    nodeDown  = mesh.getNodeAtXY(x,   y+1)
    return nodeThis, nodeRight, nodeUp, nodeLeft, nodeDown

  def rnodeCalc(self, y, x, mesh, lyr):
    nodeResis=      mesh.field[x,   y,   lyr.resis]
    nodeRightResis= mesh.field[x+1, y,   lyr.resis]
    nodeUpResis=    mesh.field[x,   y-1, lyr.resis]
    nodeLeftResis=  mesh.field[x-1, y,   lyr.resis]
    nodeDownResis=  mesh.field[x,   y+1, lyr.resis]
    return nodeResis, nodeRightResis, nodeUpResis, nodeLeftResis, nodeDownResis

  def gnodeCalc(self, nodeResis, nodeRightResis, nodeUpResis, nodeLeftResis, nodeDownResis):
    GRight= 2.0/(nodeResis + nodeRightResis)
    GUp=    2.0/(nodeResis + nodeUpResis)
    GLeft=  2.0/(nodeResis + nodeLeftResis)
    GDown=  2.0/(nodeResis + nodeDownResis)        
    GNode= GRight + GUp + GLeft + GDown + self.GDamping
    return GRight, GUp, GLeft, GDown, GNode

  def loadMatrixTopEdge(self, lyr, mesh, matls):
    if (mesh.width < 3) or (mesh.height < 2):
      return
    GBoundary= matls.boundCond
    for x in range(1, mesh.width-1):
      y = 0
      nodeThis= mesh.getNodeAtXY(x, y)
      nodeRight= mesh.getNodeAtXY(x+1, y)
      nodeLeft= mesh.getNodeAtXY(x-1, y)
      nodeDown= mesh.getNodeAtXY(x, y+1)
      
      nodeResis= mesh.field[x, y, lyr.resis]
      nodeRightResis= mesh.field[x+1, y, lyr.resis]
      nodeLeftResis= mesh.field[x-1, y, lyr.resis]
      nodeDownResis= mesh.field[x, y+1, lyr.resis]
      GRight= 2.0/(nodeResis + nodeRightResis)
      GLeft= 2.0/(nodeResis + nodeLeftResis)
      GDown= 2.0/(nodeResis + nodeDownResis)
      GNode= GRight + GLeft + GDown + self.GDamping
      self.TopEdgeNodeCount += 1

      if (mesh.ifield[x, y, lyr.isoflag] == 1):
        if self.debug == True:
          print "Setting boundaryNode te", nodeThis, " at ",x,",",y,", to temp", mesh.field[x, y, lyr.isodeg]
        GNode = self.addIsoNode(lyr, mesh, matls, nodeThis, x, y, GNode)
 
      self.A[nodeThis, nodeThis]= GNode
      self.A[nodeThis, nodeRight]= -GRight
      self.A[nodeRight, nodeThis]= -GRight
      self.A[nodeThis, nodeLeft]= -GLeft
      self.A[nodeLeft, nodeThis]= -GLeft
      self.A[nodeThis, nodeDown]= -GDown
      self.A[nodeDown, nodeThis]= -GDown
      if self.debug == True:
        self.As[nodeThis, nodeThis]= GNode
        self.As[nodeThis, nodeRight]= -GRight
        self.As[nodeRight, nodeThis]= -GRight
        self.As[nodeThis, nodeLeft]= -GLeft
        self.As[nodeLeft, nodeThis]= -GLeft
        self.As[nodeThis, nodeDown]= -GDown
        self.As[nodeDown, nodeThis]= -GDown
      if self.spice == True:
        thisSpiceNode=   "N" + str(x)   + self.s + str(y)
        spiceNodeRight=  "N" + str(x+1) + self.s + str(y)
        spiceNodeDown=   "N" + str(x)   + self.s + str(y+1)
        mesh.spiceNodeXName[thisSpiceNode] = x
        mesh.spiceNodeYName[thisSpiceNode] = y        
        RRight= 1.0/GRight
        RDown=  1.0/GDown
        self.deck += "RTER" + thisSpiceNode + " " + thisSpiceNode + " " + spiceNodeRight + " " + str(RRight) + "\n"
        self.deck += "RTED" + thisSpiceNode + " " + thisSpiceNode + " " + spiceNodeDown + " " + str(RDown) + "\n"

  def loadMatrixRightEdge(self, lyr, mesh, matls):
    if (mesh.width < 2) or (mesh.height < 3):
      return
    GBoundary= matls.boundCond
    for y in range(1, mesh.height-1):
      x= mesh.width-1
      nodeThis= mesh.getNodeAtXY(x, y)
      nodeUp= mesh.getNodeAtXY(x, y-1)
      nodeLeft= mesh.getNodeAtXY(x-1, y)
      nodeDown= mesh.getNodeAtXY(x, y+1)

      nodeResis= mesh.field[x, y, lyr.resis]
      nodeUpResis= mesh.field[x, y-1, lyr.resis]
      nodeLeftResis= mesh.field[x-1, y, lyr.resis]
      nodeDownResis= mesh.field[x, y+1, lyr.resis]
      GUp= 2.0/(nodeResis + nodeUpResis)
      GLeft= 2.0/(nodeResis + nodeLeftResis)
      GDown= 2.0/(nodeResis + nodeDownResis)
      GNode= GUp + GLeft + GDown + self.GDamping
      self.RightEdgeNodeCount += 1
      if (mesh.ifield[x, y, lyr.isoflag] == 1):
        if self.debug == True:
          print "Setting boundaryNode re", nodeThis, " at ",x,",",y,", to temp", mesh.field[x, y, lyr.isodeg]
        GNode = self.addIsoNode(lyr, mesh, matls, nodeThis, x, y, GNode)

      self.A[nodeThis, nodeThis]= GNode
      self.A[nodeThis, nodeUp]= -GUp
      self.A[nodeUp, nodeThis]= -GUp
      self.A[nodeThis, nodeLeft]= -GLeft
      self.A[nodeLeft, nodeThis]= -GLeft
      self.A[nodeThis, nodeDown]= -GDown
      self.A[nodeDown, nodeThis]= -GDown
      if self.debug == True:
        self.As[nodeThis, nodeThis]= GNode
        self.As[nodeThis, nodeUp]= -GUp
        self.As[nodeUp, nodeThis]= -GUp
        self.As[nodeThis, nodeLeft]= -GLeft
        self.As[nodeLeft, nodeThis]= -GLeft
        self.As[nodeThis, nodeDown]= -GDown
        self.As[nodeDown, nodeThis]= -GDown
      if self.spice == True:
        thisSpiceNode=   "N" + str(x)   + self.s + str(y)
        spiceNodeDown=   "N" + str(x)   + self.s + str(y+1)
        mesh.spiceNodeXName[thisSpiceNode] = x
        mesh.spiceNodeYName[thisSpiceNode] = y        
        RDown=  1.0/GDown
        self.deck += "RRED" + thisSpiceNode + " " + thisSpiceNode + " " + spiceNodeDown + " " + str(RDown) + "\n"
    
  def loadMatrixBottomEdge(self, lyr, mesh, matls):
    if (mesh.width < 3) or (mesh.height < 2):
      return
    GBoundary= matls.boundCond
    for x in range(1, mesh.width-1):
      y= mesh.height-1
      nodeThis= mesh.getNodeAtXY(x, y)
      nodeRight= mesh.getNodeAtXY(x+1, y)
      nodeUp= mesh.getNodeAtXY(x, y-1)
      nodeLeft= mesh.getNodeAtXY(x-1, y)

      nodeResis= mesh.field[x, y, lyr.resis]
      nodeRightResis= mesh.field[x+1, y, lyr.resis]
      nodeUpResis= mesh.field[x, y-1, lyr.resis]
      nodeLeftResis= mesh.field[x-1, y, lyr.resis]
      GRight= 2.0/(nodeResis + nodeRightResis)
      GUp= 2.0/(nodeResis + nodeUpResis)
      GLeft= 2.0/(nodeResis + nodeLeftResis)
      GNode= GRight + GUp + GLeft + self.GDamping
      self.BottomEdgeNodeCount += 1
      if (mesh.ifield[x, y, lyr.isoflag] == 1):
        if self.debug == True:
          print "Setting boundaryNode be", nodeThis, " at ",x,",",y,", to temp", mesh.field[x, y, lyr.isodeg]
        GNode = self.addIsoNode(lyr, mesh, matls, nodeThis, x, y, GNode)

      self.A[nodeThis, nodeThis]= GNode
      self.A[nodeThis, nodeRight]= -GRight
      self.A[nodeRight, nodeThis]= -GRight
      self.A[nodeThis, nodeUp]= -GUp
      self.A[nodeUp, nodeThis]= -GUp
      self.A[nodeThis, nodeLeft]= -GLeft
      self.A[nodeLeft, nodeThis]= -GLeft
      if self.debug == True:
        self.As[nodeThis, nodeThis]= GNode
        self.As[nodeThis, nodeRight]= -GRight
        self.As[nodeRight, nodeThis]= -GRight
        self.As[nodeThis, nodeUp]= -GUp
        self.As[nodeUp, nodeThis]= -GUp
        self.As[nodeThis, nodeLeft]= -GLeft
        self.As[nodeLeft, nodeThis]= -GLeft
      if self.spice == True:
        thisSpiceNode=   "N" + str(x)   + self.s + str(y)
        spiceNodeRight=  "N" + str(x+1) + self.s + str(y)
        mesh.spiceNodeXName[thisSpiceNode] = x
        mesh.spiceNodeYName[thisSpiceNode] = y        
        RRight= 1.0/GRight
        self.deck += "RBER" + thisSpiceNode + " " + thisSpiceNode + " " + spiceNodeRight + " " + str(RRight) + "\n"

  def loadMatrixLeftEdge(self, lyr, mesh, matls):
    if (mesh.width < 2) or (mesh.height < 3):
      return
    GBoundary= matls.boundCond
    for y in range(1, mesh.height-1):
      x= 0
      nodeThis= mesh.getNodeAtXY(x, y)
      nodeRight= mesh.getNodeAtXY(x+1, y)
      nodeUp= mesh.getNodeAtXY(x, y-1)
      nodeDown= mesh.getNodeAtXY(x, y+1)

      nodeResis= mesh.field[x, y, lyr.resis]
      nodeRightResis= mesh.field[x+1, y, lyr.resis]
      nodeUpResis= mesh.field[x, y-1, lyr.resis]
      nodeDownResis= mesh.field[x, y+1, lyr.resis]
      GRight= 2.0/(nodeResis + nodeRightResis)
      GUp= 2.0/(nodeResis + nodeUpResis)
      GDown= 2.0/(nodeResis + nodeDownResis)
      GNode= GRight + GUp + GDown + self.GDamping
      self.LeftEdgeNodeCount += 1
      if (mesh.ifield[x, y, lyr.isoflag] == 1):
        if self.debug == True:
          print "Setting boundaryNode le", nodeThis, " at ",x,",",y,", to temp", mesh.field[x, y, lyr.isodeg]
        GNode = self.addIsoNode(lyr, mesh, matls, nodeThis, x, y, GNode)

      self.A[nodeThis, nodeThis]= GNode
      self.A[nodeThis, nodeRight]= -GRight
      self.A[nodeRight, nodeThis]= -GRight
      self.A[nodeThis, nodeUp]= -GUp
      self.A[nodeUp, nodeThis]= -GUp
      self.A[nodeThis, nodeDown]= -GDown
      self.A[nodeDown, nodeThis]= -GDown
      if self.debug == True:
        self.As[nodeThis, nodeThis]= GNode
        self.As[nodeThis, nodeRight]= -GRight
        self.As[nodeRight, nodeThis]= -GRight
        self.As[nodeThis, nodeUp]= -GUp
        self.As[nodeUp, nodeThis]= -GUp
        self.As[nodeThis, nodeDown]= -GDown
        self.As[nodeDown, nodeThis]= -GDown
      if self.spice == True:
        thisSpiceNode=   "N" + str(x)   + self.s + str(y)
        spiceNodeRight=  "N" + str(x+1) + self.s + str(y)
        spiceNodeDown=   "N" + str(x)   + self.s + str(y+1)
        mesh.spiceNodeXName[thisSpiceNode] = x
        mesh.spiceNodeYName[thisSpiceNode] = y        
        RRight= 1.0/GRight
        RDown=  1.0/GDown
        self.deck += "RLER" + thisSpiceNode + " " + thisSpiceNode + " " + spiceNodeRight + " " + str(RRight) + "\n"
        self.deck += "RLED" + thisSpiceNode + " " + thisSpiceNode + " " + spiceNodeDown + " " + str(RDown) + "\n"

  def loadMatrixTopLeftCorner(self, lyr, mesh, matls):
    if (mesh.width < 2) or (mesh.height < 2):
      return
    GBoundary= matls.boundCond
    y = 0
    x = 0
    nodeThis= mesh.getNodeAtXY(x, y)
    nodeRight= mesh.getNodeAtXY(x+1, y)
    nodeDown= mesh.getNodeAtXY(x, y+1)

    nodeResis= mesh.field[x, y, lyr.resis]
    nodeRightResis= mesh.field[x+1, y, lyr.resis]
    nodeDownResis= mesh.field[x, y+1, lyr.resis]
    GRight= 2.0/(nodeResis + nodeRightResis)
    GDown= 2.0/(nodeResis + nodeDownResis)
    GNode= GRight + GDown + self.GDamping
    self.TopLeftCornerNodeCount += 1
    if (mesh.ifield[x, y, lyr.isoflag] == 1):
      if self.debug == True:
        print "Setting boundaryNode tlc", nodeThis, " at ",x,",",y,", to temp", mesh.field[x, y, lyr.isodeg]
      GNode = self.addIsoNode(lyr, mesh, matls, nodeThis, x, y, GNode)

    self.A[nodeThis, nodeThis]= GNode
    self.A[nodeThis, nodeRight]= -GRight
    self.A[nodeRight, nodeThis]= -GRight
    self.A[nodeThis, nodeDown]= -GDown
    self.A[nodeDown, nodeThis]= -GDown
    if self.debug == True:
      self.As[nodeThis, nodeThis]= GNode
      self.As[nodeThis, nodeRight]= -GRight
      self.As[nodeRight, nodeThis]= -GRight
      self.As[nodeThis, nodeDown]= -GDown
      self.As[nodeDown, nodeThis]= -GDown
    if self.spice == True:
      thisSpiceNode=   "N" + str(x)   + self.s + str(y)
      spiceNodeRight=  "N" + str(x+1) + self.s + str(y)
      spiceNodeDown=   "N" + str(x)   + self.s + str(y+1)
      mesh.spiceNodeXName[thisSpiceNode] = x
      mesh.spiceNodeYName[thisSpiceNode] = y      
      RRight= 1.0/GRight
      RDown=  1.0/GDown
      self.deck += "RTLCR" + thisSpiceNode + " " + thisSpiceNode + " " + spiceNodeRight + " " + str(RRight) + "\n"
      self.deck += "RTLCD" + thisSpiceNode + " " + thisSpiceNode + " " + spiceNodeDown + " " + str(RDown) + "\n"

  def loadMatrixTopRightCorner(self, lyr, mesh, matls):
    if ((mesh.width < 2) or (mesh.height < 2)):
      return
    GBoundary= matls.boundCond
    x= mesh.width-1
    y= 0
    nodeThis= mesh.getNodeAtXY(x, y)
    nodeLeft= mesh.getNodeAtXY(x-1, y)
    nodeDown= mesh.getNodeAtXY(x, y+1)

    nodeResis= mesh.field[x, y, lyr.resis]
    nodeLeftResis= mesh.field[x-1, y, lyr.resis]
    nodeDownResis= mesh.field[x, y+1, lyr.resis]
    GLeft= 2.0/(nodeResis + nodeLeftResis)
    GDown= 2.0/(nodeResis + nodeDownResis)
    GNode= GLeft + GDown + self.GDamping
    self.TopRightCornerNodeCount += 1
    if (mesh.ifield[x, y, lyr.isoflag] == 1):
      if self.debug == True:
        print "Setting boundaryNode trc", nodeThis, " at ",x,",",y,", to temp", mesh.field[x, y, lyr.isodeg]
      GNode = self.addIsoNode(lyr, mesh, matls, nodeThis, x, y, GNode)

    self.A[nodeThis, nodeThis]= GNode
    self.A[nodeThis, nodeLeft]= -GLeft
    self.A[nodeLeft, nodeThis]= -GLeft
    self.A[nodeThis, nodeDown]= -GDown
    self.A[nodeDown, nodeThis]= -GDown
    if self.debug == True:
      self.As[nodeThis, nodeThis]= GNode
      self.As[nodeThis, nodeLeft]= -GLeft
      self.As[nodeLeft, nodeThis]= -GLeft
      self.As[nodeThis, nodeDown]= -GDown
      self.As[nodeDown, nodeThis]= -GDown
    if self.spice == True:
      thisSpiceNode=   "N" + str(x)   + self.s + str(y)
      spiceNodeDown=   "N" + str(x)   + self.s + str(y+1)
      mesh.spiceNodeXName[thisSpiceNode] = x
      mesh.spiceNodeYName[thisSpiceNode] = y      
      RDown=  1.0/GDown
      self.deck += "RTRCD" + thisSpiceNode + " " + thisSpiceNode + " " + spiceNodeDown + " " + str(RDown) + "\n"

  def loadMatrixBottomRightCorner(self, lyr, mesh, matls):
    if (mesh.width < 2) or (mesh.height < 2):
      return
    GBoundary= matls.boundCond
    x= mesh.width-1
    y= mesh.height-1
    nodeThis= mesh.getNodeAtXY(x, y)
    nodeUp= mesh.getNodeAtXY(x, y-1)
    nodeLeft= mesh.getNodeAtXY(x-1, y)

    nodeResis= mesh.field[x, y, lyr.resis]
    nodeUpResis= mesh.field[x, y-1, lyr.resis]
    nodeLeftResis= mesh.field[x-1, y, lyr.resis]
    GUp= 2.0/(nodeResis + nodeUpResis)
    GLeft= 2.0/(nodeResis + nodeLeftResis)
    GNode= GUp + GLeft + self.GDamping
    self.BottomRightCornerNodeCount += 1
    if (mesh.ifield[x, y, lyr.isoflag] == 1):
      if self.debug == True:
        print "Setting boundaryNode trc", nodeThis, " at ",x,",",y,", to temp", mesh.field[x, y, lyr.isodeg]
      GNode = self.addIsoNode(lyr, mesh, matls, nodeThis, x, y, GNode)

    self.A[nodeThis, nodeThis]= GNode
    self.A[nodeThis, nodeUp]= -GUp
    self.A[nodeUp, nodeThis]= -GUp
    self.A[nodeThis, nodeLeft]= -GLeft
    self.A[nodeLeft, nodeThis]= -GLeft
    if self.debug == True:
      self.As[nodeThis, nodeThis]= GNode
      self.As[nodeThis, nodeUp]= -GUp
      self.As[nodeUp, nodeThis]= -GUp
      self.As[nodeThis, nodeLeft]= -GLeft
      self.As[nodeLeft, nodeThis]= -GLeft
    if self.spice == True:
      thisSpiceNode=   "N" + str(x)   + self.s + str(y)
      spiceNodeDown=   "N" + str(x)   + self.s + str(y+1)
      mesh.spiceNodeXName[thisSpiceNode] = x
      mesh.spiceNodeYName[thisSpiceNode] = y      

  def loadMatrixBottomLeftCorner(self, lyr, mesh, matls):
    if (mesh.height < 2) or (mesh.width < 2):
      return
    GBoundary= matls.boundCond
    x= 0
    y= mesh.height-1
    nodeThis= mesh.getNodeAtXY(x, y)
    nodeRight= mesh.getNodeAtXY(x+1, y)
    nodeUp= mesh.getNodeAtXY(x, y-1)

    nodeResis= mesh.field[x, y, lyr.resis]
    nodeRightResis= mesh.field[x+1, y, lyr.resis]
    nodeUpResis= mesh.field[x, y-1, lyr.resis]
    GRight= 2.0/(nodeResis + nodeRightResis)
    GUp= 2.0/(nodeResis + nodeUpResis)
    GNode= GRight + GUp + self.GDamping
    self.BottomLeftCornerNodeCount += 1
    if (mesh.ifield[x, y, lyr.isoflag] == 1):
      if self.debug == True:
        print "Setting boundaryNode blc", nodeThis, " at ",x,",",y,", to temp", mesh.field[x, y, lyr.isodeg]
      GNode = self.addIsoNode(lyr, mesh, matls, nodeThis, x, y, GNode)
      
    self.A[nodeThis, nodeThis]= GNode
    self.A[nodeThis, nodeRight]= -GRight
    self.A[nodeRight, nodeThis]= -GRight
    self.A[nodeThis, nodeUp]= -GUp
    self.A[nodeUp, nodeThis]= -GUp
    if self.debug == True:
      self.As[nodeThis, nodeThis]= GNode
      self.As[nodeThis, nodeRight]= -GRight
      self.As[nodeRight, nodeThis]= -GRight
      self.As[nodeThis, nodeUp]= -GUp
      self.As[nodeUp, nodeThis]= -GUp
    if self.spice == True:
      thisSpiceNode=   "N" + str(x)   + self.s + str(y)
      spiceNodeRight=  "N" + str(x+1) + self.s + str(y)
      mesh.spiceNodeXName[thisSpiceNode] = x
      mesh.spiceNodeYName[thisSpiceNode] = y      
      RRight= 1.0/GRight
      self.deck += "RBLCR" + thisSpiceNode + " " + thisSpiceNode + " " + spiceNodeRight + " " + str(RRight) + "\n"

  def addIsoNode(self, lyr, mesh, matls, nodeThis, x, y, GNode):
    GNode = GNode + matls.boundCond
    boundaryNode = mesh.ifield[x, y, lyr.isonode]
    self.b[self.isoIdx + mesh.nodeDcount]= mesh.field[x, y, lyr.isodeg]
    self.A[nodeThis, nodeThis]= GNode
    self.A[boundaryNode, self.isoIdx + mesh.nodeDcount]= 1.0
    self.A[self.isoIdx + mesh.nodeDcount, boundaryNode]= 1.0
    self.A[boundaryNode, boundaryNode]= matls.boundCond
    self.A[boundaryNode, nodeThis]= -matls.boundCond
    self.A[nodeThis, boundaryNode]= -matls.boundCond

    if self.debug == True:
      self.bs[self.isoIdx + mesh.nodeDcount]= mesh.field[x, y, lyr.isodeg]
      self.As[nodeThis, nodeThis]= GNode
      self.As[boundaryNode, self.isoIdx + mesh.nodeDcount]= 1.0
      self.As[self.isoIdx + mesh.nodeDcount, boundaryNode]= 1.0
      self.As[boundaryNode, boundaryNode]= self.GDamping
      self.As[boundaryNode, boundaryNode]= matls.boundCond
      self.As[boundaryNode, nodeThis]= -matls.boundCond
      self.As[nodeThis, boundaryNode]= -matls.boundCond
      print "  source vector idx= ", self.isoIdx
      print "  node with thermal source attached= ", nodeThis
      print "  node for boundary source= ", boundaryNode
      print "  row for source vector 1 multiplier= ", self.isoIdx + mesh.nodeDcount
    if self.spice == True:
      thisSpiceNode=   "N" + str(x)   + self.s + str(y)
      thisIsoSource=   "V" + thisSpiceNode
      thisBoundaryNode=  "NDIRI" + self.s + str(x) + self.s + str(y)
      thisBoundaryResistor=  "RDIRI" + self.s + str(x) + self.s + str(y)
      thisBoundaryResistance= 1.0/matls.boundCond
      self.deck += thisIsoSource + " " + thisBoundaryNode + " 0 DC " + str(mesh.field[x, y, lyr.isodeg]) + "\n"
      self.deck += thisBoundaryResistor + " " + thisSpiceNode + " " + thisBoundaryNode + " " + str(thisBoundaryResistance) + "\n"
   
    self.isoIdx = self.isoIdx + 1
    self.BoundaryNodeCount += 1
    return GNode
            
  def nonzeroMostCommonCount(self):
    """
    Find the most common number of nonzero elements in the A matrix.
    Loading this into the Trilinos solver speeds it up.
    """
    from collections import Counter 
    rowCountHist = Counter()    
    mat= self.As
    rowCount, colCount= mat.shape
    rowIndex= 0
    for row in range(0, rowCount-1): 
      row = np.array(self.As[row])
      nonzero = np.count_nonzero(row)
      rowCountHist[nonzero] += 1
      # print "Nonzero elts in row " + str(rowIndex) + " = " + str(nonzero)
      rowIndex += 1
    mostCommon= rowCountHist.most_common(1)
    mostCommonValue= mostCommon[0][0]
#   print str(rowCountHist)
#   print str(mostCommonValue)
    return mostCommonValue
  
  def solveMatrixAmesos(self):
    # The Reaper
    # x are the unknowns to be solved.
    # A is the sparse matrix describing the thermal matrix
    # b has the sources for heat and boundary conditions
    iAmRoot = self.Comm.MyPID() == 0
        
    xmulti = Epetra.MultiVector(self.Map, 1, True)
    bmulti= Epetra.MultiVector(self.Map, 1, True)
    rowCount= self.A.NumGlobalRows()
    for row in range(0, rowCount):
      bmulti[0,row]= self.b[row]
      # print "row: " + str(row) + " " + str(self.b[row])
      
    # print "LHS: " + str(xmulti)
    # print "RHS: " + str(bmulti)
    self.A.FillComplete()
    # print "Matrix: " + str(self.A)

    
    problem= Epetra.LinearProblem(self.A, xmulti, bmulti)
    # print "Problem: " + str(problem)
    solver= Amesos.Klu(problem)
    # print "Solver before solve: " + str(solver)
    solver.SymbolicFactorization()
    solver.NumericFactorization()
    ierr = solver.Solve()
    # print "Solver after solve: " + str(solver)
     
    xarr= Epetra.MultiVector.ExtractCopy(xmulti)
    xarrf= xarr.flatten()
    if iAmRoot:    
      print "Solver return status: " + str(ierr)    
      # print "xmulti, raw" + str(xmulti)
      # print "xmulti. flattened" + str(xarrf)
    
    self.x = Epetra.Vector(xarrf)
    # At this point multiply by self.A to see if it matches self.b
    bCheck= Epetra.MultiVector(self.Map, 1)
    self.A.Multiply(False, self.x, bCheck)
    # print "bCheck: " + str(bCheck)
    # print "x result:" + str(self.x)
    self.Comm.Barrier()

  def solveMatrixAztecOO(self, iterations):
    """
    Solve Ax=b
    """
    # x are the unknowns to be solved.
    # A is the sparse matrix describing the thermal matrix
    # b has the current sources for heat and Dirichlet boundary conditions
    iAmRoot = self.Comm.MyPID() == 0
    
    self.x = Epetra.Vector(self.Map)
    
    try:
      self.A.FillComplete()     
    except:
      print "Oops can't fill self.A with: " + str(self.A)
      exit
    
    # self.A.FillComplete()
    solver = AztecOO.AztecOO(self.A, self.x, self.b)
    solver.SetAztecOption(AztecOO.AZ_solver, AztecOO.AZ_cg_condnum)
    # This loads x with the solution to the problem
    ierr = solver.Iterate(iterations, 1e-8)
    
    if iAmRoot:
      print "Solver return status: " + str(ierr)
    self.Comm.Barrier()
      
  def solveEigen(self): 
    
    iAmRoot = self.Comm.MyPID() == 0
    # Most that worked for 40x40 mesh: nev         = 30
    nev         = 2
    blockSize   = nev + 1
    numBlocks   = 2 * nev
    maxRestarts = 100000
    tol         = 1.0e-8
 
    print "Create the eigenproblem"
    self.A.FillComplete()    
    myProblem = Anasazi.BasicEigenproblem(self.A, self.b)
 
    print "Inform the eigenproblem that matrix is symmetric"
    myProblem.setHermitian(True)
 
    print "Set the number of eigenvalues requested"
    myProblem.setNEV(nev)
 
    print "All done defining problem"
    if not myProblem.setProblem():
      print "Anasazi.BasicEigenProblem.setProblem() returned an error"
      return -1
 
    smallEigenvaluesParameterList = {"Which" : "SM",   # Smallest magnitude
           "Block Size"            : blockSize,
           "Num Blocks"            : numBlocks,
           "Maximum Restarts"      : maxRestarts,
           "Convergence Tolerance" : tol,
           "Use Locking"           : True}
 
    smallestEigenvalue= 0.0
    largestEigenvalue= 0.0
    # Need to try/catch here:
    try:
      smSolverMgr = Anasazi.BlockDavidsonSolMgr(myProblem, smallEigenvaluesParameterList)
      smSolverMgr.solve()
      smallestEigenvalue= self.getFirstEigenvalue(myProblem, iAmRoot, nev, tol)
      if (smallestEigenvalue <= 0.0):
        print "zero or negative smallest eigenvalue"
    except:
      print "Oops no smallest eigenvalue"
      
    largeEigenvaluesParameterList = {"Which" : "LM",   # Largest magnitude
           "Block Size"            : blockSize,
           "Num Blocks"            : numBlocks,
           "Maximum Restarts"      : maxRestarts,
           "Convergence Tolerance" : tol,
           "Use Locking"           : True}
 
    # Need to try/catch here:
    try:
      lmSolverMgr = Anasazi.BlockDavidsonSolMgr(myProblem, largeEigenvaluesParameterList)
      lmSolverMgr.solve()
      largestEigenvalue= self.getFirstEigenvalue(myProblem, iAmRoot, nev, tol)
      if (largestEigenvalue <= 0.0):
        print "zero or negative largest eigenvalue"      
    except:
      print "Oops no largest eigenvalue"
 
    if ((largestEigenvalue != 0.0) & (smallestEigenvalue != 0.0)):
      print "Largest Eigenvalue: " + str(largestEigenvalue)
      print "Smallest Eigenvalue: " + str(smallestEigenvalue)
      condNumber= largestEigenvalue / smallestEigenvalue
      print "Condition number: " + str(condNumber)

  def getFirstEigenvalue(self, myProblem, iAmRoot, nev, tol):
    # Get the eigenvalues and eigenvectors
    sol = myProblem.getSolution()
    evals = sol.Evals()
    # print "evals: " + str(evals)
    if (isinstance(evals, np.ndarray)):
      evecs = sol.Evecs()
      # print "evecs: " + str(evecs)
      if (isinstance(evecs, Epetra.MultiVector)):
        index = sol.index
        if(isinstance(index, Anasazi.VectorInt)):    
          # Check the eigensolutions
          lhs = Epetra.MultiVector(self.Map, sol.numVecs)
          self.A.Apply(evecs, lhs)
          return evals[0].real
    return 0
    
  def loadSolutionIntoMesh(self, lyr, mesh):
    """
    loadSolutionIntoMesh(Solver self, Layers lyr, Mesh mesh)
    Load the solution back into a layer on the mesh
    """
    for x in range(0, mesh.width):
      for y in range(0, mesh.height):
        nodeThis= mesh.getNodeAtXY(x, y)
        mesh.field[x, y, lyr.deg] = self.x[nodeThis]
        # print "Temp x y t ", x, y, self.x[nodeThis]

  def checkEnergyBalance(self, lyr, mesh):
    """
    checkEnergyBalance(Solver self, Layers lyr, Mesh mesh)
    Compare the power input of the simulation to the power output.
    The power input is from the current sources and the 
    power output is into the boundary conditions.
    """
    temperatureStartNode, temperatureEndNode, dirichletStartNode, dirichletEndNode = self.getNodeCounts(mesh, lyr)   
    powerIn = 0
    powerOut = 0
    for n in range(temperatureStartNode, temperatureEndNode):
      powerIn = powerIn + self.b[n]
    for n in range(dirichletStartNode, dirichletEndNode):
      powerOut = powerOut + self.x[n]
    print "Power In = ", powerIn
    print "Power Out = ", powerOut

  def getNodeCounts(self, mesh, lyr):
    """
    getNodeCounts(Solver self, Mesh mesh, Layers lyr)
    Finds indexes of regions within the Solver A matrix corresponding to different parts of the problem description.
    Return values:
    temperatureStartNode - first node number corresponding to nodes added by problem description
    temperatureEndNode - last node number corresponding to nodes added by problem description
    dirichletStartNode - first node number corresponding to extra nodes added due to Dirichlet boundary conditions
    dirichletEndNode - last node number corresponding to extra nodes added due to Dirichlet boundary conditions    
    """
    temperatureStartNode= 0
    temperatureEndNode= mesh.solveTemperatureNodeCount()
    dirichletStartNode= temperatureEndNode + mesh.nodeDcount
    dirichletEndNode= dirichletStartNode + mesh.boundaryDirichletNodeCount(lyr)
    if self.debug == True:
      print "deg Start Node= ", temperatureStartNode
      print "deg End Node= ", temperatureEndNode
      print "dirichlet Start Node= ", dirichletStartNode
      print "dirichlet End Node= ", dirichletEndNode
    return temperatureStartNode, temperatureEndNode, dirichletStartNode, dirichletEndNode

  def totalNodeCount(self):
    totalNodeCount = self.BodyNodeCount + self.TopEdgeNodeCount + self.RightEdgeNodeCount + self.BottomEdgeNodeCount + self.LeftEdgeNodeCount + self.TopLeftCornerNodeCount + self.TopRightCornerNodeCount + self.BottomRightCornerNodeCount + self.BottomLeftCornerNodeCount + self.BoundaryNodeCount
    return totalNodeCount
  
class Spice:
  """
  Run xyce based on an input spice deck, and load the output from the simulator back into the problem mesh.
  """
  def __init__(self):
    self.simbasename= 'therm'
    self.ckiname= self.simbasename + '.cki'
    self.ascname= self.simbasename + '.asc'
    self.txtname= self.simbasename + '.txt'
    self.sampleTime = 0.1
    
  def createSpiceNetlist(self, deck):
    """
    createSpiceNetlist(Spice self)
    Write a wrapper around the spice deck that was created by the
    Solver.
    """
    f= open(self.simbasename + '.cki', 'w')
    f.write("* Thermal network\n")
    f.write(deck)
    f.write(".tran .1 " + str(self.sampleTime) + "\n")
    f.write(".print tran\n")
    f.write(".end\n")
    f.close()
      
  def runSpiceNetlist(self):
    """
    runSpiceNetlist(Spice self)
    Execute Xyce in a subprocess
    """
    xycePath = "/usr/local/Xyce-Release-6.1.0-OPENSOURCE/bin"
    xyceCmd = [xycePath + "/runxyce", self.ckiname, "-a", "-r", self.ascname, "-l", self.txtname]
    thisEnv = os.environ.copy()
    thisEnv["PATH"] = xycePath + ":" + thisEnv["PATH"]
    proc= subprocess.Popen(xyceCmd, env=thisEnv)
    return proc
    
  def readSpiceResults(self, lyr, mesh):
    """
    readSpiceResults(Spice self, Layers lyr, Mesh mesh)
    Read results from spice simulation ASCII raw file output.
    Load the results back into the mesh for display.
    This requires looking up the mesh coordinates based on the spice net name.
    """
    f= open(self.simbasename + '.asc', 'r')
    # Header
    for line in f:
      if (line == 'Variables:\n'):
        break      
      (name, val)= line.strip().split(': ')
      print "Name: " + name + ", val: " + val

    # Variable names and their indexes
    for line in f:
      if (line == 'Values:\n'):
        break
      (idx, nodename, nodetype)= line.strip().split('\t')
      spiceRawIdx= int(idx)
      if (nodetype == 'time'):
        continue
      nodeIdx= spiceRawIdx - 1
      if (nodename in mesh.spiceNodeXName):
        print nodename + ": " + str(nodeIdx) + " " + str(mesh.spiceNodeXName[nodename]) + " " + str(mesh.spiceNodeYName[nodename])
        mesh.spiceNodeX.append(mesh.spiceNodeXName[nodename])
        mesh.spiceNodeY.append(mesh.spiceNodeYName[nodename])

    # ASCII data
    atSampleTime= False
    inTimePoint = True
    idx= 0
    for line in f:
      if (atSampleTime == True):
        voltage= line.strip()
        if (line == '\n'):
          break
        if (idx < len(mesh.spiceNodeX)):
          print str(idx) + ' ' + voltage + ' ' + str(mesh.spiceNodeX[idx]) + ' ' + str(mesh.spiceNodeY[idx])
          mesh.field[mesh.spiceNodeX[idx], mesh.spiceNodeY[idx], lyr.spicedeg] = voltage
          idx += 1
        continue
      if (inTimePoint == True):
        (timeIteration, time)= line.strip().split('\t')
        # Capture data near the final timepoint only
        if (abs(float(time) - self.sampleTime) < self.sampleTime/1e4):
          atSampleTime= True
          continue
      if (line == '\n'):
        inTimePoint = True
        continue
      else:
        inTimePoint = False

    f.close()
    
# This can scale by using a PNG input instead of code
def defineScalableProblem(lyr, matls, x, y):
  """
  defineScalableProblem(Layer lyr, Mesh mesh, Matls matls, int xsize, int ysize)
  Create a sample test problem for thermal analysis that can scale
  to a wide variety of sizes.
  It initializes the mesh based on fractions of the size of the mesh.
  The conductivities in the problem are based on the material properties
  in the matls object.
  """
  mesh = Mesh(x, y, lyr, matls)
  
  # Heat source
  hsx= 0.5
  hsy= 0.5
  hswidth= 0.25
  hsheight= 0.25
  heat= 10.0
  srcl= round(mesh.width*(hsx-hswidth*0.5))
  srcr= round(mesh.width*(hsx+hswidth*0.5))
  srct= round(mesh.height*(hsy-hsheight*0.5))
  srcb= round(mesh.height*(hsy+hsheight*0.5))
  numHeatCells= (srcr - srcl)*(srcb-srct)
  heatPerCell= heat/numHeatCells
  print "Heat per cell = ", heatPerCell
  mesh.field[srcl:srcr, srct:srcb, lyr.heat] = heatPerCell
  mesh.field[srcl:srcr, srct:srcb, lyr.resis] = matls.copperCond
  
  # Boundary conditions
  mesh.field[0, 0:mesh.height, lyr.isodeg] = 25.0
  mesh.field[mesh.width-1, 0:mesh.height, lyr.isodeg] = 25.0
  mesh.field[0:mesh.width, 0, lyr.isodeg] = 25.0
  mesh.field[0:mesh.width, mesh.height-1, lyr.isodeg] = 25.0
  mesh.ifield[0, 0:mesh.height, lyr.isoflag] = 1
  mesh.ifield[mesh.width-1, 0:mesh.height, lyr.isoflag] = 1
  mesh.ifield[0:mesh.width, 0, lyr.isoflag] = 1
  mesh.ifield[0:mesh.width, mesh.height-1, lyr.isoflag] = 1
  
  # Thermal conductors
  condwidth= 0.05
  cond1l= round(mesh.width*hsx - mesh.width*condwidth*0.5)
  cond1r= round(mesh.width*hsx + mesh.width*condwidth*0.5)
  cond1t= round(mesh.height*hsy - mesh.height*condwidth*0.5)
  cond1b= round(mesh.height*hsy + mesh.height*condwidth*0.5)
  mesh.field[0:mesh.width, cond1t:cond1b, lyr.resis] = matls.copperCond
  mesh.field[cond1l:cond1r, 0:mesh.height, lyr.resis] = matls.copperCond
  return mesh
  
def defineTinyProblem(lyr, matls):
  """ 
  defineTinyProblem(Layer lyr, Mesh mesh, Matls matls)
  Create a tiny test problem.
  """
  mesh = Mesh(3, 3, lyr, matls)
  
  mesh.ifield[0:3, 0, lyr.isoflag] = 1
  mesh.field[1, 1, lyr.heat]    = 2.0
  print "Mesh: " + str(mesh)
  return mesh

def Main():
  lyr = Layers()
  matls = Matls()
  # monitor = Monitors()
  # Minimal problem to confirm operation:
  # mesh = Mesh(5, 5, lyr)
  showPlots= False
  useTinyProblem= False
  
  if useTinyProblem:
    mesh = defineTinyProblem(lyr, matls)
  else:
    mesh = defineScalableProblem(lyr, matls, 300, 300)

  mesh.mapMeshToSolutionMatrix(lyr)

  solv = Solver(lyr, mesh)
  solv.initDebug()
  solv.loadMatrix(lyr, mesh, matls)
  
  if (solv.eigen == True):
    print "Solving for eigenvalues"
    solv.solveEigen()
    print "Finished solving for eigenvalues"
  
  if (solv.spice == True):
    spice= Spice()
    spice.createSpiceNetlist(solv.deck)
    proc= spice.runSpiceNetlist()
    proc.wait()
    spice.readSpiceResults(lyr, mesh)
    
  if (solv.aztec == True):
    solv.solveMatrixAztecOO(400000)
    solv.loadSolutionIntoMesh(lyr, mesh)
    solv.checkEnergyBalance(lyr, mesh) 
    
  if (solv.amesos == True):

    solv.solveMatrixAmesos()
    solv.loadSolutionIntoMesh(lyr, mesh)
    solv.checkEnergyBalance(lyr, mesh)
  
  if (solv.debug == True):
    webpage = Webpage(solv, lyr, mesh)
    webpage.createWebPage()
  
  if (showPlots == True):
    plots= interactivePlot(lyr, mesh)
    plots.plotTemperature()
    if (solv.spice == True):
      plots.plotSpicedeg()
      plots.plotLayerDifference(lyr.spicedeg, lyr.deg)
    plots.show()

showProfile= True
if showProfile == True:
  cProfile.run('Main()', 'restats')
  p = pstats.Stats('restats')
  p.sort_stats('cumulative').print_stats(30)
else:
  Main()


def gsitersolve(lyr, mesh, monitor):
  finished = 0
  iter = 0
  while ((iter < 1200) and (finished == 0)):
    monitor.powerout = 0
    monitor.powerin = 0
    delta= simstep(iter, lyr, mesh, monitor)
    print iter, delta, monitor.maxtemp, monitor.powerin, monitor.powerout
    powerbalance= (monitor.powerout - monitor.powerin)/(monitor.powerout+monitor.powerin)
    if ((iter > 10) and (abs(powerbalance) < .005)):
      finished = 1
    iter = iter + 1
    
# Times without printing much.
# Printing overhead is probably about 10% in this case.
# 10000 iterations
# 100X100 12sec
# 200x200 69sec
# 300x300 154sec

# 1000 iterations
# 200x200 14sec
# 300x300 34 sec
# 
# Design notes:
# The Mesh class 
#   Has a rectangular Numpy field that represents the problem geometry.
#   The Mesh elements are squares in a layered 2D field.
#   The field has layers that are describe by the Layers object.
#   The layers represent details about the geometry of the materials and boundary conditions.
#   Has the size of the problem, such as length, width, and the number of elements.
#   Is decorated with material properties from Matls.
#   Is decorated with the solution to the problem.
# The Layer class
#   Has enumerations that describe the layers in the Mesh
# The Map class
#   Includes a Numpy grid that is the size of the Solver.
#   Is used to access Solver information 
#   Because the solver information is not always available on the local node,
#     the Map class has a local copy of the Solver input data. Some of this
#     data is only needed for debugging and can be turned off to save space.
# The Solver class
#   Loads the and calls the Trilinos solvers.
#
    
    
# This is from http://trilinos.sandia.gov/packages/pytrilinos/UsersGuide.pdf pg 20
#   self.x = Epetra.Vector(self.Map)
#   self.A.FillComplete()

#   MLList = {
#     "max levels" : 3,
#     "output" : 10,
#     "smoother: type" : "symmetric Gauss-Seidel", 
#     "aggregation: type" : "Uncoupled"
#   };
#   # Then, we create the preconditioner and compute it,
#   Prec = ML.MultiLevelPreconditioner(self.A, False)
#   Prec.SetParameterList(MLList)
#   Prec.ComputePreconditioner()

#   # Finally, we set up the solver, and specifies to use Prec as preconditioner:

#   solver = AztecOO.AztecOO(self.A, self.x, self.b)
#   solver.SetPrecOperator(Prec)
#   solver.SetAztecOption(AztecOO.AZ_solver, AztecOO.AZ_cg); 
#   solver.SetAztecOption(AztecOO.AZ_output, 16);
#   solver.Iterate(1550, 1e-5)

# This segfaults:
# solver.SetAztecOption(AztecOO.AZ_precond, AztecOO.AZ_dom_decomp)

# This does not fail but the solution says that there is no preconditioner
# solver.SetAztecOption(AztecOO.AZ_subdomain_solve, AztecOO.AZ_ilu)

# Complains and fails
# solver.SetParameters({"precond": "dom_decomp",
#                       "subdomain_solve": "ilu",
#                       "overlap": 1,
#                       "graph_fill": 1})

# This complains and fails
# solver.SetAztecOption(AztecOO.AZ_solver, AztecOO.AZ_cg)

# This is incredibly fast but complains some:


# This appears to be the default and it works:
# solver.SetAztecOption(AztecOO.AZ_output, AztecOO.AZ_none)

# Solutions on infinite resistor grids:
# http://www.mathpages.com/home/kmath668/kmath668.htm

# Example slides, interesting python code:
# http://trilinos.org/oldsite/packages/pytrilinos/PyTrilinosTutorial.pdf