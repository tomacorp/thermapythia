from PIL import Image, ImageDraw
import numpy as np
class Mesh:

  """
  Mesh: Square mesher class for thermal analysis.
  
  The mesher takes a number of squares in the x and y direction and creates
  a square mesh from it.
  
  Counts the number of cells and the number of Dirichlet boundary conditions.
  This is required for sizing the Pytrilinos matrix before loading it.
  These Dirichlet count is needed because the boundaries also have an associated thermal
  resistance between the boundary and the square mesh.
  This resistance results in an additional node for every boundary square.
  
  Creates a bidirectional mapping from the integer X,Y 2D space to the 1D node list
  that is used for solving the sparse matrix.
  
  """

  def __init__(self, config, lyr, matls):
    """
    __init__(Mesh self, int w, int h, Layers lyr, Matls matls)
    Create a square mesh of size w by h.
    The mesh data structure is in self.field, which holds double precision numbers,
    and self.ifield, which holds integers.
    """
    self.nodeGcount = 0
    self.nodeDcount = 0
    self.nodeCount = 0
    self.nodeGBcount = 0
    self.nodeGFcount = 0 
    # Field name dictionary to map self.spicenodenum layer to string values
    # The key is the spicenodename and the value is the spicenodenum.
    self.spiceNodeName = {}
    # Dictionary that maps a node name string to the X and Y coordinates in the mesh.
    self.spiceNodeXName = {}
    self.spiceNodeYName = {}
    # Array where the index is the spicenodenum and the values are the x and y of in the mesh.
    # This allows a sequence of ordered nodes in the spice raw file output to be loaded directly back into
    # a layer in the mesh. Nodes start at 1. The first variable is time.
    self.spiceNodeX = []
    self.spiceNodeY = []

    self.defineProblem(config, lyr, matls)
    self.mapMeshToSolutionMatrix(lyr)
    
  def setMeshDefaults(self, w, h, lyr, matls):
    self.width = w
    self.height = h
    self.field = np.zeros((self.width, self.height, lyr.numdoublelayers), dtype = 'double')
    self.ifield = np.zeros((self.width, self.height, lyr.numintlayers), dtype = 'int')
    self.xr, self.yr= np.mgrid[0:self.width+1, 0:self.height+1]
    self.field[:, :, lyr.heat]  = 0.0
    self.field[:, :, lyr.resis] = matls.fr4ResistancePerSquare
    self.field[:, :, lyr.deg]   = 20
    self.field[:, :, lyr.flux]  = 0.0
    self.field[:, :, lyr.isodeg] = 25.0
    self.ifield[:, :, lyr.isoflag] = 0
    self.ifield[:, :, lyr.isonode] = 0     

  def solveTemperatureNodeCount(self):
    """ 
    solveTemperatureNodeCount(Mesh self)
    Returns the count of cells in the square mesh.
    """
    # The node count is one more than the maximum index.
    # getNodeAtXY starts a 0
    count= self.getNodeAtXY(self.width - 1, self.height - 1) + 1
    return count

  def boundaryDirichletNodeCount(self, lyr):
    """
    boundaryDirichletNodeCount(Mesh self, int lyr)
    Returns the count of the nodes generated by adding Dirichlet boundary conditions.

    """
    count = 0;
    for x in range(0, self.width):
      for y in range(0, self.height):
        if (self.ifield[x, y, lyr.isoflag] == 1):
          count = count + 1
    return count

  def getNodeAtXY(self, x, y):
    """
    getNodeAtXY(Mesh self, int x, int y)
    Given an integer x and y argument, find the corresponding node number
    """
    node= x + (y * self.width)
    return node

  def getXAtNode(self, node):
    """
    def getXAtNode(Mesh self, int node)
    Given a node, find the x coordinate of the mesh element
    """
    if (node > self.width * self.height - 1):
      return ''
    x = node % self.width
    return x
  
  def getYAtNode(self, node):
    """
    def getXAtNode(Mesh self, int node)
    Given a node, find the y coordinate of the mesh element
    """    
    if (node > self.width * self.height - 1):
      return ''
    x = self.getXAtNode(node)
    y = node - x
    y = y / self.width
    return y

  def mapMeshToSolutionMatrix(self, lyr):
    """
    mapMeshToSolutionMatrix(Mesh self, Layers lyr)
    Based on the mesh, find the number of the different types of nodes
    that will be in the matrix A. These numbers need to be known in
    advance of constructing the matrix.
    The input is the width and height of the mesh, and the field with
    the location of the Dirichlet boundary condition nodes.
    One node is for the 1 off-diagonal entries for the voltage sources,
    and the second node is because there is a resistor that connects
    the Dirichlet boundary condition to the mesh. This means that the
    voltage source creates another voltage node.
    """
    self.nodeGcount = self.getNodeAtXY(self.width - 1, self.height - 1)
    self.nodeCount = self.nodeGcount + 1
    self.nodeGFcount = self.nodeCount
    # Find the number of nodes in the submatrices
    for x in range(0, self.width):
      for y in range(0, self.height):
        if (self.ifield[x, y, lyr.isoflag] == 1):
          # print "Mapping mesh isothermal node at (x, y) = (", x, ", ", y, ")"
          # Every boundary condition gets a new node
          self.nodeGcount = self.nodeGcount + 1
          self.nodeGBcount = self.nodeGBcount + 1
          self.nodeCount = self.nodeCount + 1
          # Every boundary condition gets a new voltage source
          self.nodeDcount = self.nodeDcount + 1
          self.ifield[x, y, lyr.isonode] = self.nodeGcount
          self.nodeCount = self.nodeCount + 1
    self.nodeGcount = self.nodeGcount + 1
    print "Number of independent nodes in G matrix= ", self.nodeGcount
    print "Number of independent nodes in GF matrix= ", self.nodeGFcount
    print "Number of independent nodes in GB matrix= ", self.nodeGBcount
    print "Number of independent nodes in D matrix= ", self.nodeDcount
    print "Total number of independent nodes= ", self.nodeCount
    
  # This can scale by using a PNG input instead of code
  def defineScalableProblem(mesh, lyr, matls, x, y):
    """
    defineScalableProblem(Layer lyr, Mesh mesh, Matls matls, int xsize, int ysize)
    Create a sample test problem for thermal analysis that can scale
    to a wide variety of sizes.
    It initializes the mesh based on fractions of the size of the mesh.
    The conductivities in the problem are based on the material properties
    in the matls object.
    """
    mesh.setMeshDefaults(x, y, lyr, matls)
    
    # Heat source
    hsx= 0.5
    hsy= 0.5
    hswidth= 0.25
    hsheight= 0.25
    heat= 10.0
    srcl= round(mesh.width*(hsx-hswidth*0.5))
    srcr= round(mesh.width*(hsx+hswidth*0.5))
    srct= round(mesh.height*(hsy-hsheight*0.5))
    srcb= round(mesh.height*(hsy+hsheight*0.5))
    numHeatCells= (srcr - srcl)*(srcb-srct)
    heatPerCell= heat/numHeatCells
    print "Heat per cell = ", heatPerCell
    mesh.field[srcl:srcr, srct:srcb, lyr.heat] = heatPerCell
    mesh.field[srcl:srcr, srct:srcb, lyr.resis] = matls.copperResistancePerSquare
    
    # Boundary conditions
    mesh.field[0, 0:mesh.height, lyr.isodeg] = 25.0
    mesh.field[mesh.width-1, 0:mesh.height, lyr.isodeg] = 25.0
    mesh.field[0:mesh.width, 0, lyr.isodeg] = 25.0
    mesh.field[0:mesh.width, mesh.height-1, lyr.isodeg] = 25.0
    mesh.ifield[0, 0:mesh.height, lyr.isoflag] = 1
    mesh.ifield[mesh.width-1, 0:mesh.height, lyr.isoflag] = 1
    mesh.ifield[0:mesh.width, 0, lyr.isoflag] = 1
    mesh.ifield[0:mesh.width, mesh.height-1, lyr.isoflag] = 1
    
    # Thermal conductors
    condwidth= 0.05
    cond1l= round(mesh.width*hsx - mesh.width*condwidth*0.5)
    cond1r= round(mesh.width*hsx + mesh.width*condwidth*0.5)
    cond1t= round(mesh.height*hsy - mesh.height*condwidth*0.5)
    cond1b= round(mesh.height*hsy + mesh.height*condwidth*0.5)
    mesh.field[0:mesh.width, cond1t:cond1b, lyr.resis] = matls.copperResistancePerSquare
    mesh.field[cond1l:cond1r, 0:mesh.height, lyr.resis] = matls.copperResistancePerSquare
  
  def definePNGProblem(mesh, fn, lyr, matls):
    """
    Read a PNG file and load the data structure
    """
    heatPerCell= 48e-6
    pngproblem = Image.open(fn, mode='r')
    xysize= pngproblem.size
    width= xysize[0]
    height= xysize[1]
    print "Width: " + str(width) + " Height: " + str(height)
  
    mesh.setMeshDefaults(width, height, lyr, matls)
  
    pix = pngproblem.load()
    copperCellCount=0
    padCellCount=0
    isoCellCount=0
    for xn in range(0,width-1):
      for tyn in range(0, height-1):
        # Graphing package has +y up, png has it down
        yn= height - 1 - tyn
        if pix[xn,yn][0] > 0: 
          mesh.field[xn, tyn, lyr.resis] = matls.copperResistancePerSquare
          mesh.field[xn, tyn, lyr.heat] = heatPerCell
          copperCellCount += 1
          padCellCount += 1
        if pix[xn,yn][1] > 0:
          mesh.field[xn, tyn, lyr.resis] = matls.copperResistancePerSquare
          copperCellCount += 1
        if pix[xn,yn][2] > 0:
          mesh.ifield[xn, tyn, lyr.isoflag] = 1
          mesh.field[xn, tyn, lyr.isodeg] = 25.0
          isoCellCount += 1
          
    print "Copper px: " + str(copperCellCount) + " Pad px: " + str(padCellCount) + " Iso px: " + str(isoCellCount)
    
  def defineTinyProblem(mesh, lyr, matls):
    """ 
    defineTinyProblem(Layer lyr, Mesh mesh, Matls matls)
    Create a tiny test problem.
    """
    mesh.setMeshDefaults(3, 3, lyr, matls)
    
    mesh.ifield[0:3, 0, lyr.isoflag] = 1
    mesh.field[1, 1, lyr.heat]    = 2.0
    print "Mesh: " + str(mesh)
    
  def defineProblem(mesh, config, lyr, matls):
    foundProblem= 0
    for problem in config:
      if problem['active'] == 1:
        if (problem['type'] == "tiny"):
          mesh.defineTinyProblem(lyr, matls)
          foundProblem= 1
        if (problem['type'] == "png"):
          mesh.definePNGProblem(problem['file'], lyr, matls)
          foundProblem= 1
        if (problem['type'] == "scalable"):
          mesh.defineScalableProblem(lyr, matls, problem['xsize'], problem['ysize'])
          foundProblem= 1
    if foundProblem == 0:
      print "Problem not specified or not found in configuration"
          